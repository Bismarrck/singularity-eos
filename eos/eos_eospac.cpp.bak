//------------------------------------------------------------------------------
// Â© 2021. Triad National Security, LLC. All rights reserved.  This
// program was produced under U.S. Government contract 89233218CNA000001
// for Los Alamos National Laboratory (LANL), which is operated by Triad
// National Security, LLC for the U.S.  Department of Energy/National
// Nuclear Security Administration. All rights in the program are
// reserved by Triad National Security, LLC, and the U.S. Department of
// Energy/National Nuclear Security Administration. The Government is
// granted for itself and others acting on its behalf a nonexclusive,
// paid-up, irrevocable worldwide license in this material to reproduce,
// prepare derivative works, distribute copies to the public, perform
// publicly and display publicly, and to permit others to do so.
//------------------------------------------------------------------------------

#include "eos.hpp"

// This is bit rotted, but it's for the EOSPAC reader.

namespace singularity {

//---------------------
// EOSPAC reader
//---------------------
TabularEOS::TabularEOS(std::string& name)
{
    // Read in EOS table from "name", including associated metadata
    _name = name;
    // Initialize cache state_for_mat
    _cache_rho = -1.;
    _cache_temp = -1.;
}

TabularEOS::TabularEOS(ParameterInput *pin, std::string& block_name)
{
  _eos_type = TabularType();
}


// TODO: where do the const's go?

void TabularEOS::FillEos(Real& rho, Real& temp, Real& energy, Real& press, Real& cv, Real& bmod, const unsigned long output, Real *lambda)
{
    QuerySetTableCache(rho, temp);

    if (output&thermalqs::specific_internal_energy) {
        energy = Interp(_sie_table, _cache_irho, _cache_itemp, _cache_delr, _cache_delt);
    }
    if (output&thermalqs::pressure) {
        press = Interp(_press_table, _cache_irho, _cache_itemp, _cache_delr, _cache_delt);
    }
    if (output&thermalqs::specific_heat) {
        cv = Interp(_cv_table, _cache_irho, _cache_itemp, _cache_delr, _cache_delt);
    }
    if (output&thermalqs::bulk_modulus) {
        bmod = Interp(_bmod_table, _cache_irho, _cache_itemp, _cache_delr, _cache_delt);
    }
}

/*
void TabularEOS::FillEos(Variable<Real>& rho, Variable<Real>& temp, Variable<Real>& energy, Variable<Real>& press, Variable<Real>& cv, Variable<Real>& bmod, const unsigned long output) {

    SetInternals(rho, temp);

    if (output&specific_internal_energy) {
        for (int i = 0; i < rho.GetSize(); ++i) {
            energy(i) = Interp(_sie_table, _irho(i), _itemp(i), _delr(i), _delt(i));
        }
    }
    if (output&pressure) {
        for (int i = 0; i < rho.GetSize(); ++i) {
            press(i) = Interp(_press_table, _irho(i), _itemp(i), _delr(i), _delt(i));
        }
    }
    if (output&specific_heat) {
        for (int i = 0; i < rho.GetSize(); ++i) {
            cv(i) = Interp(_cv_table, _irho(i), _itemp(i), _delr(i), _delt(i));
        }
    }
    if (output&bulk_modulus) {
        for (int i = 0; i < rho.GetSize(); ++i) {
            bmod(i) = Interp(_bmod_table, _irho(i), _itemp(i), _delr(i), _delt(i));
        }
    }

    ResetInternals();
}
*/
int TableIndex(const Real lq, const Real lq0, const Real dlq)
{
    return (lq - lq0)/dlq;
}
Real TableInterpAlpha(const Real lq, const int iq, const Real lq0, const Real dlq)
{
    return (lq - (lq0 + iq*dlq))/dlq;
}
void TabularEOS::SetInternals(Variable<Real>& rho, Variable<Real>& temp)
{
    int n = rho.GetSize();
    _irho.NewAthenaArray(n);
    _itemp.NewAthenaArray(n);
    _delr.NewAthenaArray(n);
    _delt.NewAthenaArray(n);
    _lvar.NewAthenaArray(n);

    std::transform(rho.begin(), rho.end(), _lvar.begin(), [](Real rho){return log(rho);});
    std::transform(_lvar.begin(), _lvar.end(), _irho.begin(), 
        [=](Real lrho){return TableIndex(lrho, _lrho_lo, _dlrho);});
    std::transform(_lvar.begin(), _lvar.end(), _irho.begin(), _delr.begin(), 
        [=](Real lrho, int irho){return TableInterpAlpha(lrho, irho, _lrho_lo, _dlrho);});

    std::transform(temp.begin(), temp.end(), _lvar.begin(), [](Real temp){return log(temp);});
    std::transform(_lvar.begin(), _lvar.end(), _itemp.begin(), 
        [=](Real ltemp){return TableIndex(ltemp, _ltemp_lo, _dltemp);});
    std::transform(_lvar.begin(), _lvar.end(), _itemp.begin(), _delt.begin(), 
        [=](Real ltemp, int itemp){return TableInterpAlpha(ltemp, itemp, _ltemp_lo, _dltemp);});

    _lvar.DeleteAthenaArray();
}
Real TabularEOS::Interp(const AthenaArray<Real>& table, const int irho, const int itemp, const Real delr, const Real delt)
{
    return (table(irho,itemp)*(1-delr)*(1-delt) +
            table(irho,itemp+1)*(1-delr)*delt   +
            table(irho+1,itemp)*delr*(1-delt)   +
            table(irho+1,itemp+1)*delr*delt);

}
void TabularEOS::ResetInternals()
{
    _irho.DeleteAthenaArray();
    _itemp.DeleteAthenaArray();
    _delr.DeleteAthenaArray();
    _delt.DeleteAthenaArray();
}
Real TabularEOS::TemperatureFromDensityInternalEnergy(const Real rho, const Real sie, Real *lambda)
{
    // TODO: think about how to pass in an initial guess and do a linear search instead of a root find
    Real lrho = log(rho);
    int irho = TableIndex(lrho, _lrho_lo, _dlrho);
    Real delr = TableInterpAlpha(lrho, irho, _lrho_lo, _dlrho);
    Real ltl = _ltemp_lo;
    Real fl = sie-Interp(_sie_table, irho, 0, delr, 0.0);
    Real ltr = _ltemp_hi;
    Real fr = sie-Interp(_sie_table, irho, _Ntemp-1, delr, 1.0);

    if (fl*fr > 0) {
        // TODO: INVOKE ERROR HANDLING
    }

    // TODO: do better than bisection
    while (ltr - ltl > 0.5*_dltemp) {
        Real ltm = 0.5*(ltl + ltr);
        int itemp = TableIndex(ltm, _ltemp_lo, _dltemp);
        Real delt = TableInterpAlpha(ltm, itemp, _ltemp_lo, _dltemp);
        Real fm = sie-Interp(_sie_table, irho, itemp, delr, delt);

        if (fm*fl < 0) {
            fr = fm;
            ltr = ltm;
        } else {
            fl = fm;
            ltl = ltm;
        }
    }

    Real ltm = 0.5*(ltl + ltr);
    int itemp = TableIndex(ltm, _ltemp_lo, _dltemp);
    fl = Interp(_sie_table, irho, itemp, delr, 0.);
    fr = Interp(_sie_table, irho, itemp, delr, 1.);
    
    // refine
    Real delt;
    if (fl < sie && fr > sie) {
        // temperautre is between itemp and itemp+1
        delt = (sie - fl)/(fr - fl);
    } else if (fr < sie) {
        itemp++;
        fl = Interp(_sie_table, irho, itemp, delr, 0.);
        fr = Interp(_sie_table, irho, itemp, delr, 1.);
        delt = (sie - fl)/(fr - fl);
    } else if (sie < fl) {
        itemp--;
        fl = Interp(_sie_table, irho, itemp, delr, 0.);
        fr = Interp(_sie_table, irho, itemp, delr, 1.);
        delt = (sie - fl)/(fr - fl);
    }
    return exp(_ltemp_lo + (itemp+delt)*_dltemp);
}
void TabularEOS::QuerySetTableCache(const Real rho, const Real temp)
{
    if (rho != _cache_rho) {
        Real lrho = log(rho);
        _cache_irho = TableIndex(lrho, _lrho_lo, _dlrho);
        _cache_delr = TableInterpAlpha(lrho, _cache_irho, _lrho_lo, _dlrho);
    }
    if (temp != _cache_temp) {
        Real ltemp = log(temp);
        _cache_itemp = TableIndex(ltemp, _ltemp_lo, _dltemp);
        _cache_delt = TableInterpAlpha(ltemp, _cache_itemp, _ltemp_lo, _dltemp);
    }
}
Real TabularEOS::InternalEnergyFromDensityTemperature(const Real rho, const Real temp, Real *lambda)
{
    QuerySetTableCache(rho, temp);
    return Interp(_sie_table, _cache_irho, _cache_itemp, _cache_delr, _cache_delt);
}
Real TabularEOS::PressureFromDensityTemperature(const Real rho, const Real temp, Real *lambda)
{
    QuerySetTableCache(rho, temp);
    return Interp(_press_table, _cache_irho, _cache_itemp, _cache_delr, _cache_delt);
}
Real TabularEOS::SpecificHeatFromDensityTemperature(const Real rho, const Real temp, Real *lambda)
{
    QuerySetTableCache(rho, temp);
    return Interp(_cv_table, _cache_irho, _cache_itemp, _cache_delr, _cache_delt);
}
Real TabularEOS::BulkModulusFromDensityTemperature(const Real rho, const Real temp, Real *lambda)
{
    QuerySetTableCache(rho, temp);
    return Interp(_bmod_table, _cache_irho, _cache_itemp, _cache_delr, _cache_delt);
}
Real TabularEOS::PressureFromDensityInternalEnergy(const Real rho, const Real sie, Real *lambda) { return 0.0; }
Real TabularEOS::SpecificHeatFromDensityInternalEnergy(const Real rho, const Real sie, Real *lambda) { return 0.0; }
Real TabularEOS::BulkModulusFromDensityInternalEnergy(const Real rho, const Real sie, Real *lambda) { return 0.0; }

} // namespace singularity
